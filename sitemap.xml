<search>
    
     <entry>
        <title>SpringDataJapNotes</title>
        <url>https://iankingh.github.io/post/spring/springdatajapnotes/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>java</tag><tag>Spring</tag><tag>Spring Data JPA</tag>
        </tags>
        <content type="html"> Spring Data JPA 介紹 Spring-Data 概述  Spring Data 是一個資料訪問框架 ，用於簡化資料庫訪問，旨在提供一致的資料庫訪問模型，同時仍然保留不同資料庫底層資料存儲的特點，Spring Data 採用了領域驅動模型的設計思想，實現了訪問關係型數據庫、非關係型數據庫的統一的介面，只需要定義好領域模型（Entity），後續的創建表、CURD、排序操作不需要手動添加任何SQL語句，同時也支持手動擴展功能。
Spring Data 只要定義介面，遵循 Spring Data 的規範，就無需寫實現類。
Spring Data 提供了預設的交易處理方式，即所有的查詢均聲明為唯讀事務。
Spring Data 專案所支援 NoSQL 存儲：MongoDB （文檔資料庫）、Neo4j（圖形資料庫）、Redis（鍵/值存儲）、Hbase（列族資料庫）
Spring Data 專案所支援的關係資料存儲技術：JDBC、JPA
 Spring Data JPA 概述  JPA(Java Persistence API)是 Sun 官方提出的 Java 持久化規範。
JPA主要是為了簡化現有的持久化開發工作和整合 ORM 技術， 是在充分吸收了現有 Hibernate、TopLink、JDO 等 ORM 框架的基礎上發展而來的，具有易於使用、伸縮性強等優點。
Spring Data JPA 是 Spring 基於 ORM 框架、JPA 規範的基礎上封裝的一套 JPA 應用框架，可使開發者用簡單代碼即可實現對資料的訪問和操作。
它提供了包括增刪改查等在內的常用功能，且易於擴展！通常我們寫持久層，都是先寫一個介面，再寫介面對應的實現類，在實現類中進行持久層的業務邏輯處理。而現在，Spring Data JPA幫助我們自動完成了持久層的業務邏輯處理，開發者唯一要做的，就只是聲明持久層的介面，其他都交給 Spring Data JPA 來幫你完成！
注意：JPA 是一套規範，不是一套產品， Hibernate、TopLink、JDO 它們是一套產品，如果說這些產品實現了這個 JPA 規範，那麼就可以叫它們為 JPA 的實現產品。
 Repository Repository介面 Repository 介面是 Spring Data 的一個核心介面，是一個抽象的介面，使用者通過繼承該介面來實現資料的訪問，它不提供任何方法，開發者需要在自己定義的介面中聲明需要的方法
public interface Repository&amp;lt;T, ID&amp;gt; { } 很重要的一點就是，Repository的實現類是在應用啟動的時候生成的，也就是Spring的應用上下文創建的時候.而不是通過代碼生成技術產生的，也不是介面方法調用時才產生的 基礎的Repository提供了最基本的資料訪問功能，其幾個子介面則擴展了一些功能。
編寫Spring Data JPA Repository 的關鍵在於從一組介面中挑選一個進行擴展
EX:
public interface CustomerRepository extends Repository&amp;lt;CustomerEntity,Long&amp;gt; { } 添加注解為其指定 CustomerEntity和 id 屬性。
在spring boot中如果使用了 spring-boot-starter-data-jpa ,會自動掃描所有擴展了Repository介面的類
CrudRepository 介面 CrudRepository 介面繼承Repository，提供對實體類(CRUD)增刪改查方法，可以直接調用。
CrudRepository介面實現了save、delete、count、exists等方法，繼承這個介面時需要兩個範本參數T和ID，T就是你的實體類（對應資料庫表），ID就是主鍵。
public interface CrudRepository&amp;lt;T, ID extends Serializable&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; {&amp;lt;S extends T&amp;gt; S save(S entity); //Saves the given entity (保存給定的實體。)Optional&amp;lt;T&amp;gt; findById(ID primaryKey); //Returns the entity identified by the given ID.(返回由給定ID標識的實體。)Iterable&amp;lt;T&amp;gt; findAll(); //Returns all entities.(返回所有實體。)long count();//Returns the number of entities.(查詢實體數量) void delete(T entity); //	Deletes the given entity.(刪除給定的實體。)boolean existsById(ID primaryKey); //Indicates whether an entity with the given ID exists.(根據id判斷實體是否存在)void delete(ID id);//根據Id刪除實體 &amp;lt;S extends T&amp;gt; Iterable&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entities);//保存集合} 在使用中，使用者需要繼承這個介面，CustomerEntity就是定義的實體，Long是主鍵類型
public interface CustomerRepository extends CrudRepository&amp;lt;CustomerEntity, Long&amp;gt;{} package com.example.demo;import java.util.ArrayList;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/*** CustomerRepositoryTest*/@SpringBootTestpublic class CustomerRepositoryTest {@Autowiredprivate UserRepository userRepository;// CRUD 操作// 增 save(entity), save(entities)@Testpublic void save1() {UserEntity userEntity = new UserEntity();userEntity.setName(&amp;quot;肯德基20&amp;quot;);userEntity = userRepository.save(userEntity);System.out.println(userEntity);}// save(entities)@Testpublic void saveManyTest() {UserEntity userEntity = new UserEntity();userEntity.setName(&amp;quot;test21&amp;quot;);UserEntity userEntity2 = new UserEntity();userEntity2.setName(&amp;quot;test22&amp;quot;);ArrayList&amp;lt;UserEntity&amp;gt; userEntities = new ArrayList&amp;lt;UserEntity&amp;gt;();userEntities.add(userEntity);userEntities.add(userEntity2);userRepository.saveAll(userEntities);}} // 刪 delete(id),delete(entity),delete(entities),deleteAll// 查 findOne(id) ,findAll, exits(id)// save***只要 id一樣,就會更新,而不是添加. PagingAndSortingRepository 介面 繼承CrudRepository，具有分頁查詢和排序功能
public interface PagingAndSortingRepository&amp;lt;T, ID extends Serializable&amp;gt; extends CrudRepository&amp;lt;T, ID&amp;gt; {Iterable&amp;lt;T&amp;gt; findAll(Sort sort); //排序Page&amp;lt;T&amp;gt; findAll(Pageable pageable); //分頁查詢（含排序功能）} **example: **
package com.example.demo;import java.util.ArrayList;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/*** CustomerRepositoryTest*/@SpringBootTestpublic class CustomerRepositoryTest {@Autowiredprivate CustomerRepository customerRepository;@Testpublic void findAll() {Iterable iterable = customerRepository.findAll();System.out.println(&amp;quot;iterable &amp;quot; &#43; iterable);}} JpaRepository 介面 繼承 PagingAndSortingRepository，實現一組 JPA 規範相關的方法， 該介面提供了JPA的相關功能 ，PagingAndSortingRepository介面本身已經繼承了 CrudRepository
public interface JpaRepository&amp;lt;T,ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T,ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt;{List&amp;lt;T&amp;gt; findAll(); //查找所有實體List&amp;lt;T&amp;gt; findAll(Sort sort); //排序、查找所有實體List&amp;lt;T&amp;gt; save(Iterable&amp;lt;? extends T&amp;gt; entities);//保存集合T saveAndFlush(T entity);//強制執行持久化void flush();//執行緩存與資料庫同步void deleteInBatch(Iterable&amp;lt;T&amp;gt; entities);//刪除一個實體集合} JpaSpecificationExecutor介面 可以執行原生SQL查詢也可以自訂Repository的方法不屬於Repository體系，實現一組 JPA Criteria 查詢相關的方法 Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
由於JpaSpecificationExecutor 並不繼承repository 介面，所以它不能單獨使用，只能和jpa Repository 一起用。
public interface JpaSpecificationExecutor&amp;lt;T&amp;gt; {T findOne(Specification&amp;lt;T&amp;gt; spec);List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec);Page&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Pageable pageable);List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Sort sort);long count(Specification&amp;lt;T&amp;gt; spec);} public interface CustomerRepository extends CrudRepository&amp;lt;Customer, Long&amp;gt;, JpaSpecificationExecutor {} Spring-Data 方法定義規範 public interface ProductInfoRepository extends JpaRepository&amp;lt;ProductInfoEntity,String&amp;gt; {//定義一個方法:根據商品名稱查找所有的商品List&amp;lt;ProductInfoEntity&amp;gt; findAllByProductName(String name);} 當創建 Repository 實現的時候， Spring Data會檢查 Repository 介面的所有方法，解析方法的名稱，並基於被持久化的物件來推測方法的目的，Spring Data 定義了一組小型的領域特定語言(DSL) ，在這裡持久化的細節都是通過 Repository的方法簽名來描述的
findAllByProductName(String name) 方法非常簡單，Repoditory 方法是 由一個動詞，一個可選主題,關鍵字By以及一個斷言所組成
在findAllByProductName 方法中,動詞是findAll ,斷言是 ProductName，主題並沒有指定，
暗含就是 ProductInfoEntity Repository 方法的主題是可選的,它主要是讓你命名方法的時候有很多的靈活性,findAllByProductName和findAllProductInfoEntityByProductName方法沒有什麼區別. 要查詢的物件的類型是通過如何參數化 Repository 介面來決定的,而不是方法名稱中的主題.
擴展查詢 按照Spring Data 的規範，查詢方法以find | read | get 開頭， 涉及條件查詢時，條件的屬性用條件關鍵字連接，要注意的是：條件屬性以首字母大寫。
find | read | get方法都會查詢資料並返回物件.而 count 則會返回匹配對象的數量,而不是對象本身.
EX：定義一個 Entity 實體類
class UserEntity｛private String firstName; private String lastName; ｝ 使用And條件連接時，應這樣寫：
findByLastNameAndFirstName(String lastName,String firstName); 假如創建如下的查詢：findByUserDepUuid()，框架在解析該方法時，首先剔除 findBy，然後對剩下的屬性進行解析，假設查詢實體為Doc （1）先判斷 userDepUuid （根據 POJO 規範，首字母變為小寫）是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，繼續第二步； （2）從右往左截取第一個大寫字母開頭的字串(此處為Uuid)，然後檢查剩下的字串是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，則重複第二步，繼續從右往左截取；最後假設 user 為查詢實體的一個屬性； （3）接著處理剩下部分（DepUuid），先判斷 user 所對應的類型是否有depUuid屬性，如果有，則表示該方法最終是根據 “ Doc.user.depUuid” 的取值進行查詢；否則繼續按照步驟 2 的規則從右往左截取，最終表示根據 “Doc.user.dep.uuid” 的值進行查詢。 （4）可能會存在一種特殊情況，比如 Doc包含一個 user 的屬性，也有一個 userDep 屬性，此時會存在混淆。可以明確在屬性之間加上 &amp;ldquo;_&amp;rdquo; 以顯式表達意圖，比如 &amp;ldquo;findByUser_DepUuid()&amp;rdquo; 或者 &amp;ldquo;findByUserDep_uuid()&amp;rdquo; 特殊的參數： 還可以直接在方法的參數上加入分頁或排序的參數，比如：
Page&amp;lt;UserModel&amp;gt; findByName(String name, Pageable pageable);List&amp;lt;UserModel&amp;gt; findByName(String name, Sort sort); 如果覺得curdrepository提供的查詢不符合要求，可以繼承該介面進行擴展，
Spring Data JPA為此提供了一些表達條件查詢的關鍵字，大致如下：
條件的屬性名稱與個數要與參數的位置與個數一一對應 直接在介面中定義查詢方法，如果是符合規範的，可以不用寫實現，目前支援的關鍵字寫法如下：
   Keyword Description Sample     And 等價於SQL中的and 關鍵字 findByUsernameAndPassword(String user, Striang pwd)；   Or 等價於SQL中的or 關鍵字 findByUsernameOrAddress(String user, String addr);   Between 等價於SQL中的between 關鍵字 findBySalaryBetween(int max,int min)；   LessThan 等價於SQL中的&amp;quot;&amp;lt;&amp;rdquo; findBySalaryLessThan(int max)；   GreaterThan 等價於SQL中的&amp;quot;&amp;gt;&amp;rdquo; findBySalaryGreaterThan(intmin)；   IsNull 等價於SQL中的&amp;quot;is null&amp;rdquo; findByUsernameIsNull()；   IsNotNull 等價於SQL中的&amp;quot;is not null&amp;rdquo; findByUsernameIsNotNull()；   NotNull 與IsNotNull等價    Like 等價於SQL中的&amp;quot;like&amp;rdquo; findByUsernameLike(String user)；   NotLike 等價於SQL中的&amp;quot;not like&amp;rdquo; findByUsernameNotLike(Stringuser)；   OrderBy 等價於SQL中的&amp;quot;order by&amp;rdquo; findByUsernameOrderBySalaryAsc(String user)；   Not 等價於SQL中的&amp;rdquo;！ =&amp;rdquo; findByUsernameNot(String user)；   In 等價於SQL中的&amp;quot;in&amp;rdquo; findByUsernameIn(CollectionuserList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數；   NotIn 等價於SQL中的&amp;quot;not in&amp;rdquo; findByUsernameNotIn(CollectionuserList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數；    @Query注解 Spring Data 這個小型的DSL依舊有其局限性,有時候通過方法名表達預期的查詢很繁瑣,甚至無法實現.如果與呆這種情況,Spring Data能讓我們通過**@Query**注解來解決問題
這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
如果是 @Query 中有 LIKE 關鍵字，後面的參數需要前面或者後面加 %，這樣在傳遞參數值的時候就可以不加 %：
@Query注解 這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
自訂 Repository 方法 定義一個介面: 聲明要添加的, 並自實現的方法 提供該介面的實現類: 類名需在要聲明的 Repository 後添加 Impl, 並實現方法 聲明 Repository 介面, 並繼承 1) 聲明的介面 使用. 注意: 預設情況下, Spring Data 會在 base-package 中查找 &amp;ldquo;介面名Impl&amp;rdquo; 作為實現類. 也可以通過　repository-impl-postfix　聲明尾碼
@Query(&amp;quot;select o from UserModel o where o.name like %?1&amp;quot;) @Query來指定本地查詢 使用**@Query**來指定本地查詢，只要設置**nativeQuery**為**true**
@Query(value=&amp;quot;select * from tbl_user where name like %?1&amp;quot; ,nativeQuery=true) @Query 與 @Modifying 這兩個 annotation一起聲明，可定義個性化更新操作，例如只涉及某些欄位更新時最為常用
Springdata支援JPQL 語句對查詢進行擴展，
例子如下：
public interface CustomerRepository extends CrudRepository&amp;lt;Customer, Long&amp;gt; { @Query(&amp;quot;select a from Customer a WHERE a.firstName = ?1&amp;quot;)List&amp;lt;Customer&amp;gt; findByQuery(StringfirstName); }  EX:
//聲明自訂查詢/***	使用JPA SQL語句*	@return**/@Query(&amp;quot;select p from ProductInfoEntity p where p.productName like &#39;%米%&#39; &amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findProductInfo(); /***	使用JPA SQL語句 查詢價格最高的商品**/@Query(&amp;quot;select p from ProductInfoEntity p &amp;quot; &#43;&amp;quot;where p.productPrice=&amp;quot; &#43;&amp;quot;(select max(p2.productPrice) from ProductInfoEntity p2)&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findMaxPrice(); /*** 使用JPA SQL語句 帶參數的查詢1* @param name* @param price* @return**/@Query(&amp;quot;select o from ProductInfoEntity o where o.productName=?1 and o.productPrice=?2&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findParam(String name, double price); /*** 使用JPASQL語句 帶參數的查詢2* @param name* @param price* @return**/@Query(&amp;quot;select o from ProductInfoEntity o where o.productName=:name and o.productPrice=:price&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findParam2(@Param(&amp;quot;name&amp;quot;) String name, @Param(&amp;quot;price&amp;quot;) double price);當然還可以使用原生SQL語句進行查詢,只需要 nativeQuery = true 即可 /***使用原生SQL語句 查詢* @return**/@Query(nativeQuery = true,value = &amp;quot;select count(*) from product_info&amp;quot;)Integer getCount(); Spring data JPA 更新及刪除操作整合事物的使用
更新操作注意事項:
/** 使用Query注解寫更新JPA語句*添加 @Modifying 注解**/@Modifying@Query(&amp;quot;update ProductInfoEntity o set o.productPrice =:price where o.productId=:id&amp;quot;)Integer updatePrice(@Param(&amp;quot;id&amp;quot;) String id,@Param(&amp;quot;price&amp;quot;) double price);  在service層添加事物 @Transactional  package com.itguang.weixinsell.service;import com.itguang.weixinsell.repository.ProductInfoRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Transactionalpublic class ProductInfoService {@Autowiredprivate ProductInfoRepository infoRepository;public Integer updatePrice( String id,double price){Integer i = infoRepository.updatePrice(id, price);return i;}}</content>
    </entry>
    
     <entry>
        <title>docker 指令</title>
        <url>https://iankingh.github.io/post/docker/docker_command/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>docker</tag>
        </tags>
        <content type="html"> images see images(看鏡像) docker images docker pull docker pull see registry images curl -XGET 172.22.11.11:5000/v2/_catalog container docker container ls (看容器) docker container ls docker ps (看容器) docker ps -a : 看到的所有容器 docker ps -a  -l :顯示最新創建的容器(包括所有狀態) docker ps -l -q :只顯示數字ID docker ps -q  -f: 過濾器 docker ps -f id=ContainerId Container Stop (停掉Container) docker stop  Container remove(移除停掉的Container) docker rm see log docker logs Show Container&amp;rsquo;s logs (once) docker logs ContainerId Log countinuing docker logs -f ContainerId See Container ENV docker inspect Cid &amp;gt; Y.txt (獲取容器/鏡像的 ENV。) Into Container (進入 container 裡面) docker exec -it containerID bash  into 執行命令 docker exec -it ebbeb7c38404 bash -c &#39;echo &amp;quot;$envKey&amp;quot;&#39; stop &amp;amp;&amp;amp; rm docker container docker stop ContainerId &amp;amp;&amp;amp; docker rm ContainerId Container status (查看docker 容器使用的資源) docker stats  提交一個commit docker commit cID docker system docker system df (空間分佈) docker system df 可用於查詢鏡像（Images）、容器（Containers）和本地卷（Local Volumes）等空間使用大戶的空間佔用情況。
-v 表示細節查看空間佔用細節 docker system df -v docker system prune (空間清理) 可以通過 Docker 內置的 CLI 指令 docker system prune 來進行自動空間清理。
docker system prune WARNING! This will remove:
- all stopped containers (已經停止的容器（container）)
- all networks not used by at least one container(未被使用的網路)
- all dangling images(Dangling images are layers that have no relationship to any tagged images.)(所有未打標籤的鏡像(images)。)
- all dangling build cache(構建鏡像時產生的緩存)
該指令預設只會清除懸空鏡像，未被使用的鏡像不會被刪除。
· 添加 -a 或 --all 參數後，可以一併清除所有未使用的鏡像和懸空鏡像。
· 可以添加 -f 或 --force 參數用以忽略相關告警確認資訊。
· 指令結尾處會顯示總計清理釋放的空間大小。
刪除已經停止的容器： docker container prune 刪除未被使用的網路： docker network prune 刪除沒有Tag的鏡像： docker image prune 刪除沒有容器的鏡像： docker image prune -a 刪除未被使用的資料卷： docker volume prune Docker swarm see swarm service ls docker service ls see swarm service status docker service ps serviceID update service env docker service update --env-add envKey=envValue serviceName update service docker service update --image 172.22.11.11:5000/dockerImageName:tag swarmS_Name 參考 docker 官網
Docker常用命令小记_程序员欣宸的博客-CSDN博客
https://blog.csdn.net/boling_cavalry/article/details/101145739
docker container ls命令 - Docker教程™
https://www.yiibai.com/docker/container_ls.html
</content>
    </entry>
    
     <entry>
        <title>Java DecimalFormat(數字格式)</title>
        <url>https://iankingh.github.io/post/java/java_decimalformat/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 簡介 java.text提供了NumberFormat類別來讓我們更方便的格式化數字的呈現方式
DecimalFormat是NumberFormat該格式的具體子類， 其格式為小數。它具有多種功能，旨在使可以在任何語言環境中解析和格式化數字，包括對西方，阿拉伯和印度數字的支持。它還支持各種數字，包括整數（123），定點數字（123.4），科學計數法（1.23E4），百分比（12％）和貨幣金額（$ 123）。所有這些都可以本地化。
基本用法 NumberFormat //	由於NumberFormat是一個抽象類別，必須用getInstance()來取得他裡面的方法NumberFormat nf = NumberFormat.getInstance();//	NumberFormat物件格式化的方式是固定的，都是以每三位數一個逗號的方式格式化數字，浮點數欄位則是有的時候顯示，沒有就不顯示。所以可以得到1,234,567.89。System.out.println(nf.format(1234567.89)); DecimalFormat ​	DecimalFormat實作了NumberFormat，並提供更客製化的格式選擇，用法如下：
Double value = 123456.789;String pattern = &amp;quot;###,###.###&amp;quot; ;//	宣告了一個DecimalFormat物件，並可以在宣告時帶入要格式化的格式，若不帶入參數，格式規則和NumberFormat相同。DecimalFormat myFormatter = new DecimalFormat(pattern);String output = myFormatter.format(value);System.out.println(&amp;quot;執行結果為：&amp;quot; &#43; value &#43; &amp;quot; &amp;quot; &#43; pattern &#43; &amp;quot; &amp;quot; &#43; output); ​	下表描述了前幾行代碼的輸出. value 是要格式化的數字(double) ,pattern 是指定格式設置屬性的字符串.The output, 輸出是字符串，表示格式化的數字。
   value pattern output Explanation     123456.789 ###,###.### 123,456.789 井號（＃）表示一個數字，逗號是分組分隔符的佔位符，句點是十進制分隔符的佔位符。   123456.789 ###.## 123456.79 value 在小數點右邊有三位數, 而 pattern 只有兩位. format通過四捨五入來解決這個問題。   123.78 000000.000 000123.780 pattern 指定前導零和尾隨零，因為使用0字符代替了井號（＃）。   12345.67 $###,###.### $12,345.67 pattern中的第一個字符是美元符號（$）。注意，它緊接在格式為output的最左邊的數字之前。   12345.67 \u00A5###,###.### ¥12,345.67 pattern 使用Unicode值00A5指定日元（¥）的貨幣符號。    其他用法 DecimalFormat df = new DecimalFormat(&amp;quot;$#,##0.00&amp;quot;);System.out.println(df.format(1234567.2)); ​	格式化的字串中0代表一定要有值，#則代表不一定要有值， 因此#,##0.00表示至少要有個位數及小數點後兩位，且每三位數以一個逗號分開，若格式化的數字沒有個位數或小數點後兩位，就會以0代替。
​	根據需求在前後加上需要的文字，例如$符號，所以上例執行的結果就會是$1,234,567.20。
這邊要注意若是我們在格式化字串結尾加上百分比符號『%』，DecimalFormat會自動幫我們將數值乘以100以符合字面意義，例如：
DecimalFormat df = new DecimalFormat(&amp;quot;#,##0.00%&amp;quot;);System.out.println(&amp;quot;執行結果為：&amp;quot; &#43; df.format(1234567.2));// 執行結果為：123,456,720.00% DecimalFormat 類主要靠 # 和 0 兩種預留位置號來指定數位長度。
0 表示如果位數不足則以 0 填充，# 表示只要有可能就把數字拉上這個位置。
/*** DecimalFormatTest*/public class DecimalFormatTest {public static void main(String[] args) {double d = 123456789;DecimalFormat decimalFormat = new DecimalFormat(&amp;quot;#,###.##&amp;quot;);System.out.println(decimalFormat.format(d));DecimalFormat decimalFormat2 = new DecimalFormat(&amp;quot;#,###.00&amp;quot;);System.out.println(decimalFormat2.format(d));double pi = 3.1415927;// 圓周率// 取一位元整數System.out.println(new DecimalFormat(&amp;quot;0&amp;quot;).format(pi));// 3// 取一位元整數和兩位元小數System.out.println(new DecimalFormat(&amp;quot;0.00&amp;quot;).format(pi));// 3.14// 取兩位元整數和三位元小數，整數不足部分以0填補。System.out.println(new DecimalFormat(&amp;quot;00.000&amp;quot;).format(pi));// 03.142// 取所有整數部分System.out.println(new DecimalFormat(&amp;quot;#&amp;quot;).format(pi));// 3// 以百分比方式計數，並取兩位小數System.out.println(new DecimalFormat(&amp;quot;#.##%&amp;quot;).format(pi));// 314.16%long c = 299792458;// 光速// 顯示為科學計數法，並取五位小數System.out.println(new DecimalFormat(&amp;quot;#.#####E0&amp;quot;).format(c));// 2.99792E8// 顯示為兩位元整數的科學計數法，並取四位小數System.out.println(new DecimalFormat(&amp;quot;00.####E0&amp;quot;).format(c));// 29.9792E7// 每三位以逗號進行分隔。System.out.println(new DecimalFormat(&amp;quot;,###&amp;quot;).format(c));// 299,792,458// 將格式嵌入文本System.out.println(new DecimalFormat(&amp;quot;光速大小為每秒,###米&amp;quot;).format(c)); // 光速大小為每秒299,792,458米}} 參考 [Java] 13-8 數字輸出格式 @ 給你魚竿 :: 痞客邦
https://rx1226.pixnet.net/blog/post/335106917
數字格式(NumberFormat、DecimalFormat) @ Penguin 工作室，一起JAVA吧！ :: 隨意窩 Xuite日誌
https://blog.xuite.net/jane17512001/PenguinDesign/116288108-%E6%95%B8%E5%AD%97%E6%A0%BC%E5%BC%8F%28NumberFormat%E3%80%81DecimalFormat%29
（轉）Java DecimalFormat 用法（數位格式化） - 濫好人 - 博客園
https://www.cnblogs.com/hq233/p/6539107.html
https://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html
https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html
</content>
    </entry>
    
     <entry>
        <title>[從 0 開始的 JAVA 生活]No.0 java環境變數 (Environment Variable)設定</title>
        <url>https://iankingh.github.io/post/java/java_tutorial_0/</url>
        <categories>
          <category>筆記</category><category>技術</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 設定JAVA_HOME C:\Program Files\Java\jdk1.8.0_111(後面為自己的jdk) Path %JAVA_HOME%\bin; 測試 java -vresionjavac -version </content>
    </entry>
    
     <entry>
        <title>RedisInstall</title>
        <url>https://iankingh.github.io/post/redis/redisinstall/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>redis</tag>
        </tags>
        <content type="html"> 簡介 Redis是一個使用ANSI C編寫的開源、支援網路、基於記憶體、可選永續性的鍵值對儲存資料庫。
安裝 Window 下 安裝 安裝網址 https://github.com/microsoftarchive/redis/releases
啟動指令 redis-server.exe redis.windows.conf 啟動畫面 測試 //連線指令redis-cli.exe -h 127.0.0.1 -p 6379// 塞值Set testkey testvalue// 取值Get testkey Linux 安裝 $ wget http://download.redis.io/releases/redis-6.0.3.tar.gz$ tar xzf redis-6.0.3.tar.gz$ cd redis-6.0.3$ make 啟動 src/redis-server 測試 //連線指令src/redis-cli // 塞值redis&amp;gt; set foo bar // 取值redis&amp;gt; get foo  參考 Redis - 維基百科，自由的百科全書
https://zh.wikipedia.org/wiki/Redis
Redis - 在 Windows 上建立高可用性的 Redis | 天空的垃圾場
https://skychang.github.io/2017/04/09/Redis-Create_Redis_HA/
Redis系列 - 環境建置篇 - Jed&amp;rsquo;s blog
https://jed1978.github.io/2018/05/02/Redis-Environment-Installation-Configuration.html
</content>
    </entry>
    
     <entry>
        <title>[從 0 開始的 JAVA 生活]No.2 Java 基本的資料型態(Primitive Data Types)</title>
        <url>https://iankingh.github.io/post/java/java_tutorial_1/</url>
        <categories>
          <category>筆記</category><category>技術</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> Java 基本的資料型態(Primitive Data Types)    序號 數據類型 大小/位 封裝類 默認值 可表示數據范圍     1 byte 8bit Byte 0 -128~127   2 short 16bit Short 0 -32768~32767   3 int 32bit Integer 0 -2147483648~2147483647   4 long 64bit Long 0L -9223372036854775808~9223372036854775807   5 float 32bit Float 0.0F 1.4E-45~3.4028235E38   6 double 64bit Double 0.0D 4.9E-324~1.7976931348623157E308   7 char 16bit Character &amp;lsquo;\u0000&amp;rsquo; 0~65535   8 boolean 8bit Boolean false true或false    範例 package ch1;/*** * * &amp;lt;p/&amp;gt;* Package: ch1 &amp;lt;br&amp;gt;* File Name: PrimitiveDataTypesTest &amp;lt;br&amp;gt;* &amp;lt;p/&amp;gt;* Purpose: &amp;lt;br&amp;gt;* * @ClassName: ch1.PrimitiveDataTypesTest* @Description: 測試基本數據類型* @Copyright : Copyright (c) Corp. 2020. All Rights Reserved.* @Company: ian Team.* @author ian* @version 1.0, 2020年5月18日*/public class PrimitiveDataTypesTest {static byte b;static short s;static int i;static long l;static float f;static double d;static char c;static boolean bo;// String不是基本類型static String str1 = &amp;quot;&amp;quot;;// 生成一個String類型的引用，而且分配記憶體空間來存放&amp;quot;&amp;quot;;static String str2; // 只生成一個string類型的引用；不分配記憶體空間,預設為nullpublic static void main(String[] args) {System.out.println(&amp;quot;byte的大小：&amp;quot; &#43; Byte.SIZE &#43; &amp;quot; byte的預設值：&amp;quot; &#43; b &#43; &amp;quot; byte的資料範圍：&amp;quot; &#43; Byte.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Byte.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;short的大小：&amp;quot; &#43; Short.SIZE &#43; &amp;quot; short的預設值：&amp;quot; &#43; s &#43; &amp;quot; short的資料範圍：&amp;quot; &#43; Short.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Short.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;int的大小：&amp;quot; &#43; Integer.SIZE &#43; &amp;quot; int的預設值：&amp;quot; &#43; i &#43; &amp;quot; int的資料範圍：&amp;quot; &#43; Integer.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Integer.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;long的大小：&amp;quot; &#43; Long.SIZE &#43; &amp;quot; long的預設值：&amp;quot; &#43; l &#43; &amp;quot; long的資料範圍：&amp;quot; &#43; Long.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Long.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;float的大小：&amp;quot; &#43; Float.SIZE &#43; &amp;quot; float的預設值：&amp;quot; &#43; f &#43; &amp;quot; float的資料範圍：&amp;quot; &#43; Float.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Float.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;double的大小：&amp;quot; &#43; Double.SIZE &#43; &amp;quot; double的預設值：&amp;quot; &#43; d &#43; &amp;quot; double的資料範圍：&amp;quot; &#43; Double.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Double.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;char的大小：&amp;quot; &#43; Character.SIZE &#43; &amp;quot; char的預設值：&amp;quot; &#43; c &#43; &amp;quot; char的資料範圍：&amp;quot; &#43; Character.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Character.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;boolean的大小：&amp;quot; &#43; Byte.SIZE &#43; &amp;quot; boolean的預設值：&amp;quot; &#43; bo &#43; &amp;quot; boolean的資料範圍：&amp;quot; &#43; Byte.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Byte.MAX_VALUE);System.out.println(&amp;quot;String字串的預設值：&amp;quot; &#43; str1 &#43; &amp;quot;str的默認長度：&amp;quot; &#43; str1.length());System.out.println(&amp;quot;String字串的預設值：&amp;quot; &#43; str2);}} JAVA 跳脫字元 Escape Characters - \&#39; : 單引號- \&amp;quot; : 雙引號- \\ : 反斜線- \n : 換行- \t : tab鍵- \b : 倒退一格- \f : 換頁- \r : Enter 鍵 參考
Java中8種基本數據類型默認的默認值_java_飛月程序人生-CSDN博客
https://blog.csdn.net/fysuccess/article/details/40656761
</content>
    </entry>
    
     <entry>
        <title>OpenTypeHierarchy</title>
        <url>https://iankingh.github.io/post/eclipse/opentypehierarchy/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>eclispe</tag>
        </tags>
        <content type="html"> Eclipse 用 Open Type Hierarchy 查看類的繼承關係 用Open Type Hierarchy可以查看類的繼承關係，可以在Hierarchy窗口看到繼承層次的導航。
在方法或類名上點擊右鍵，選擇Open Type Hierarchy即可，快捷鍵是F4。
</content>
    </entry>
    
     <entry>
        <title>Hugo 使用 disqus</title>
        <url>https://iankingh.github.io/post/hugo/hugoaddisqus/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> Hugo ADD disqus Disqus（/dɪsˈkʌs/，與英語「discuss」同音）是一家使用社群網路形式，向網路社區提供網站留言服務的公司。 該公司的平台提供不同的功能，例如與不同社群網路服務連結、社群網路、用戶個人檔案、垃圾宣傳及審核工具、資料分析、電子郵件通知和在行動裝置留言等。
Config.toml 開啟Hugo配置檔 Config.toml，設定 DisqusShortname。
disqusShortname = &amp;quot;yourDisqusShortname&amp;quot; 新增 disqus.html 在根目錄 /layouts/partials/ 裡新增 disqus.html 檔案， 然後把官方提供的 Script 貼到 disqus.html 檔案裡並存檔。 官方提供的 Script 如下：
&amp;lt;div id=&amp;quot;disqus_thread&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;(function () {// Don&#39;t ever inject Disqus on localhost--it creates unwanted// discussions from &#39;localhost:1313&#39; on your Disqus account...if (window.location.hostname == &amp;quot;localhost&amp;quot;)return;var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;var disqus_shortname = &#39;{{ .Site.DisqusShortname }}&#39;;dsq.src = &#39;//&#39; &#43; disqus_shortname &#43; &#39;.disqus.com/embed.js&#39;;(document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);})();&amp;lt;/script&amp;gt;&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&amp;quot;http://disqus.com/?ref_noscript&amp;quot;&amp;gt;comments powered byDisqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;&amp;lt;a href=&amp;quot;http://disqus.com/&amp;quot; class=&amp;quot;dsq-brlink&amp;quot;&amp;gt;comments powered by &amp;lt;span class=&amp;quot;logo-disqus&amp;quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt; 設定 disqus.html 到 Hugo 主題的目錄下，找到 single.html 檔案， 將 Hugo 主題的目錄下 single.html Copy 至 /layouts/_default/ 下。 開啟 /layouts/_default/single.html 檔案，貼上下方語法
&amp;lt;div class=&amp;quot;disqus markdown&amp;quot;&amp;gt;{{ partial &amp;quot;disqus.html&amp;quot; . }}&amp;lt;/div&amp;gt; 解決 localhost 不顯示 的問題 這是因為官方所提供的 Script 裡面其中一段語法的關係 if (window.location.hostname == &amp;ldquo;localhost&amp;rdquo;) return; 它的作用是當本地端 Server 運行時，就 return 中止，所以我們才會看不到 Disqus，這是因為當自己在編輯文章並運行 Server 進行預覽時，不需要用到留言的功能，所以才會採用這個判斷式來避免本地端的 Server 模式啟用Disqus功能。若您希望在本地端 Server 模式下，也能看到 Disqus，只要把上述那二行給註解掉並存檔就可以了。 ShowDisqus
參考 Hugo 加入 Disqus 整合性留言管理系統
https://coreychen71.github.io/posts/2019-05/hugoadddisqus/
给Hugo添加disqus评论服务 - Marvin&amp;rsquo;s Blog【程式人生】
https://zh4ui.net/post/2017-04-20-hugo-with-disqus/
为你博客添加disqus评论系统 | 23.9K | Vineo
https://vineo.cn/config-disqus.html
</content>
    </entry>
    
     <entry>
        <title>Prism.js使用筆記</title>
        <url>https://iankingh.github.io/post/hugo/hugoaddprism/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> hugo使用Prism.js 使用 prism.js 做為代碼高量的工具
Prism是一種輕量級的，可擴展的語法突出顯示工具，其構建考慮了現代Web標準。它已在數千個網站中使用，包括您每天訪問的一些網站。
下載 https://prismjs.com/
使用 你的Hugo部落格資料夾位置├── static│ ├── prism.js│ └── prism.css Config.toml 開啟Hugo配置檔 Config.toml，設定將預設代碼高亮設定false
#預設代碼區塊pygmentsCodefences = falsepygmentsCodefencesGuessSyntax = false 參考 Hugo動態加載prism.js https://www.ariesme.com/post/2019/add_prism_for_hugo_automatically/
Hugo / 如何在 Hugo 中用 Prism.js 提供程式碼色彩標註 | sujj blog
https://sujingjhong.com/posts/how-to-add-prismjs-into-hugo/
漂亮的代碼語法高亮插件Prism.js簡單使用文檔 - 嚴穎專欄 -SegmentFault 思否
https://segmentfault.com/a/1190000009122617
</content>
    </entry>
    
     <entry>
        <title>Hugo使用筆記</title>
        <url>https://iankingh.github.io/post/hugo/hugonotes/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> Hugo使用筆記 建立及設定部落格專案
我們先使用 hugo 命令新增一個空白專案，然後下載一個Template到我們的專案裡面
接著新增四個我們想加到模板 Menu 的頁面: about, history, tags, categories
最後則是新增一篇空白的文章到專案內。
1.create the project $ hugo new site myblog 2.add a theme $ git submodule add https://github.com/laozhu/hugo-nuo themes/hugo-nuo 3.add new pages $ hugo new about.md $ hugo new hisroty.md $ hugo new tags.md $ hugo new categories.md 4.add new article $ hugo new post/welcome.md  參考 右上角github 貓
GitHub Corners
http://tholman.com/github-corners/
在 Github Pages 建立 Hugo 靜態網站 · Kaichu.io
https://kaichu.io/2015/07/12/my-first-post/
使用Github部署Hugo靜態網站
https://kira5033.github.io/2019/05/%E4%BD%BF%E7%94%A8github%E9%83%A8%E7%BD%B2hugo%E9%9D%9C%E6%85%8B%E7%B6%B2%E7%AB%99/
https://github.com/xtfly/xtfly.github.io/tree/hugo/themes/next
使用 Hugo 打造個人部落格
https://blog.walker088.tw/post/intro-hugo/
hugo搭建静态博客 | 生信笔记 https://www.bioinfo-scrounger.com/archives/809/
</content>
    </entry>
    
</search>