<search>
    
     <entry>
        <title>Git_error</title>
        <url>https://iankingh.github.io/post/git/git_error/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html"> gi pull error筆記 當 git pull 出現
error: Your local changes to the following files would be overwritten by merge: 意思是本地新修改的程式碼檔案，將會被git伺服器上的程式碼覆蓋
解決方法如下：
方法1： 使用stash 如果你想保留剛才本地修改的程式碼，並把git伺服器上的程式碼pull到本地（本地剛才修改的程式碼將會被暫時封存起來）
$ git stash $ git pull origin master$ git stash pop **注：**用 pop 指令，可以把某個 Stash 拿出來並套用在目前的分支上。套用成功之後，那個套用過的 Stash 就會被刪除。
方法2 : 放棄變更 如果你想完全地覆蓋本地的程式碼，只保留伺服器端程式碼，則直接回退到上一個版本，再進行pull： $ git reset --hard$ git pull origin master 注： 其中origin master表示git的主分支。
方法3 : 使用分支( 推薦 正統)  切分支出去commit 在切回 master fetch 再進行 merge  $ git checkout -b &amp;lt;branch&amp;gt;$ git commit -m &amp;quot;add dev&amp;quot; $ git checkout master $ git merge master 注： 感謝 KFC 前輩的提供正確解決衝突的教學
參考 git pull遇到錯誤：error: Your local changes to the following files would be overwritten by merge:解決方法
https://www.itread01.com/content/1545046022.html
【狀況題】手邊的工作做到一半，臨時要切換到別的任務 - 為你自己學 Git | 高見龍
https://gitbook.tw/chapters/faq/stash.html
</content>
    </entry>
    
     <entry>
        <title>Docker_Compose</title>
        <url>https://iankingh.github.io/post/docker/docker_compose/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>docker</tag>
        </tags>
        <content type="html"> Docker_Compose筆記 安裝Compose 1.下載 sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose 2.安裝 chmod &#43;x /usr/local/bin/docker-compose 3.查看版本 docker-compose version 測試
第一步，創建 Spring boot 服務 在
 第二步，创建 Dockerfile 同样在此目录下，我们创建一个 Dockerfile 文件。
FROM python:3.4-alpineADD . /codeWORKDIR /codeDㄟRUN pip install -r requirements.txtCMD [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;] 第三步，使用 Compose 文件定义一个服务 在当期目录下，我们创建一个 docker-compose.yml 文件，内容如下：
version: &#39;2&#39;services:web:build: .ports:- &amp;quot;5000:5000&amp;quot;redis:image: &amp;quot;redis:alpine&amp;quot; 这个 Compose 文件定义了两个服务, 一个 Pyhon Web 服务和 redis 服务。
 Pyhon Web 服务：使用 Dockerfile 构建了当前镜像。将 Web 容器内部的5000端口映射到 host 的5000端口；并将 Web 容器与 redis 容器连接。 redis服务：该容器直接由官方的 redis 镜像创建。  第四步，使用 Compose 使用命令docker-compose up启动
version: &#39;2&#39;services:web:build: .command: python app.pyports:- &amp;quot;5000:5000&amp;quot;volumes:- .:/coderedis:image: &amp;quot;redis:alpine&amp;quot; 启动成功之后，在浏览器访问：http://ipaddress:5000/ ，返回如下：
Hello World! I have been seen 1 times. 刷新再次访问返回
Hello World! I have been seen 2 times. 不断的刷新数字会不断的增长。
Docker Compose 常用命令 使用docker-compose up -d在后台启动服务
[root@localhost composetest]# docker-compose up -d 使用docker-compose ps命令查看启动的服务
[root@localhost composetest]# docker-compose psName Command State Ports -------------------------------------------------------------------------------------composetest_redis_1 docker-entrypoint.sh redis ... Up 6379/tcp composetest_web_1 python app.py Up 0.0.0.0:5000-&amp;gt;5000/tcp 使用docker-compose stop停止服务。
[root@localhost composetest]# docker-compose stopStopping composetest_web_1 ... doneStopping composetest_redis_1 ... done 其它常用命令
#查看帮助docker-compose -h# -f 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。docker-compose -f docker-compose.yml up -d #启动所有容器，-d 将会在后台启动并运行所有的容器docker-compose up -d#停用移除所有容器以及网络相关docker-compose down#查看服务容器的输出docker-compose logs#列出项目中目前的所有容器docker-compose ps#构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务docker-compose build#拉取服务依赖的镜像docker-compose pull#重启项目中的服务docker-compose restart#删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。docker-compose rm #在指定服务上执行一个命令。docker-compose run ubuntu ping docker.com#设置指定服务运行的容器个数。通过 service=num 的参数来设置数量docker-compose scale web=3 db=2#启动已经存在的服务容器。docker-compose start#停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。docker-compose stop 參考 Docker(四)：Docker 三剑客之 Docker Compose - 纯洁的微笑博客
http://www.ityouknow.com/docker/2018/03/22/docker-compose.htm
https://docs.docker.com/compose/install/
</content>
    </entry>
    
     <entry>
        <title>AngularDeployTomcat</title>
        <url>https://iankingh.github.io/post/angular/angulardeploytomcat/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>Angular</tag>
        </tags>
        <content type="html"> Angular Deploy Tomcat 1. 編譯 到專案目錄執行 編譯指令如下
ng build --prod --base-href /project_Name/  匯出 index.html 如下
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;base href=&amp;quot;/project_Name/&amp;quot;&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt; &amp;lt;link rel=&amp;quot;icon&amp;quot; type=&amp;quot;image/x-icon&amp;quot; href=&amp;quot;favicon.ico&amp;quot;&amp;gt; &amp;lt;link href=&amp;quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500&amp;amp;display=swap&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt; &amp;lt;link href=&amp;quot;https://fonts.googleapis.com/icon?family=Material&#43;Icons&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;styles.479444a78a429503e78e.css&amp;quot;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body class=&amp;quot;mat-typography&amp;quot;&amp;gt; &amp;lt;app-root&amp;gt;&amp;lt;/app-root&amp;gt; &amp;lt;script src=&amp;quot;runtime.c51bd5b1c616d9ffddc1.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;polyfills-es5.272209ba9e789fcad1c2.js&amp;quot; nomodule defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;polyfills.7f244a820a4deda6d9fd.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;main.d604dab66ca826078124.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  &amp;ndash;prod : 把 src/environments/environment.ts 檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多
&amp;ndash;output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下
&amp;ndash;base-href : 修改 index.html 裡的 : ex : 2.部屬 把project/dist裡的project的資料夾 移動到 $Tomcat/webapps
3. Deploy Tomcat9 調整 server.xml，將 http port 改為 80，https port 改為 443。
&amp;lt;Connector port=&amp;quot;80&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot; connectionTimeout=&amp;quot;20000&amp;quot; redirectPort=&amp;quot;443&amp;quot; /&amp;gt;  4. Installing services Install the service named &amp;lsquo;Tomcat9&amp;rsquo;
service.bat install  5. 404 如何解決 因為 Angular 是 SPA，所以在網頁伺服器要將所有的 request 全部導回到 index.html 才可以正常地顯示，如果在沒有設定下直接打開網址 web/home，他會去找 home 資料夾下的 index.html
(1)將以下代碼放在部署文件夾的web.xml中：
&amp;lt;error-page&amp;gt; &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt; &amp;lt;location&amp;gt;/index.html&amp;lt;/location&amp;gt; &amp;lt;/error-page&amp;gt;  (2)將HashLocationStrategy與路由的URL中的＃一起使用
修改 app-routing.module.ts
使用: RouterModule.forRoot(routes, { useHash: true }) 代替: RouterModule.forRoot(routes)
使用HashLocationStrategy，您的網址將類似於：
http://localhost/#/route
app-routing.module.ts
@NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], exports: [RouterModule] })  (3) Tomcat URL Rewrite Valve：如果找不到資源，則使用服務器級別的配置來重寫URL，以重定向到index.html。
(3.1)在server.xml中配置RewriteValve
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;Context&amp;gt; &amp;lt;Valve className=&amp;quot;org.apache.catalina.valves.rewrite.RewriteValve&amp;quot; /&amp;gt; &amp;lt;/Context&amp;gt;  (3.2)在rewrite.config中寫入重寫規則
創建目錄結構–〜/ conf / Catalina / localhost /並使用以下內容在其中創建rewrite.config文件。注意-這裡我考慮將其/web作為應用程序的上下文路徑。
RewriteCond %{REQUEST_PATH} !-f RewriteRule ^/web/(.*) /web/index.html  參考
https://angular.io/guide/deployment
https://tomcat.apache.org/tomcat-9.0-doc/windows-service-howto.html
https://stackoverflow.com/questions/51042875/url-rewriting-angular-4-on-tomcat-8-server
https://blog.miniasp.com/post/2017/01/17/Angular-2-deploy-on-IIS
https://forum.angular.tw/t/topic/881/12
https://forum.angular.tw/t/topic/1839/2
</content>
    </entry>
    
     <entry>
        <title>DockerFile</title>
        <url>https://iankingh.github.io/post/docker/dockerfile/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>docker</tag>
        </tags>
        <content type="html"> Dockerfile Dockerfile 是用來描述映像檔（image）的文件。
所謂的 Image，就是生產 Container 的模版，你可以從 Docker Hub 官方下載或是根據官方的 Image 自己加工後打包成 Image 或是完全自己使用 Dockerfile 描述 Image 內容來製作 Image。
而 Container 則是透過 Image 產生隔離的執行環境，稱之為 Container，也就是我們一般用來提供 microservice 的最小單位。
簡單示例 Dockerfile 一般位於構建上下文的根目錄下，也可以通過-f指定該檔的位置：
$ docker build -f /path/to/a/Dockerfile . 構建時，還可以通過-t參數指定構建成鏡像的倉庫、標籤。
映像標籤
$ docker build -t nginx:v1 . 命令最後有一個. 表示目前的目錄
#從Docker hub 下載基礎的 image，可能是作業系統環境或是程式語言環境FROM nginx#維護者資訊MAINTAINER ianhunag@gmail.com # 鏡像操作指令執行 CMD 指令跑的指令RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html 使用 docker run 命令來啟動容器
$ docker run --name docker_nginx_v1 -d -p 80:80 nginx:v1 這條命令會用 nginx 鏡像啟動一個容器，命名為docker_nginx_v1，並且映射了 80 埠，這樣我們可以用流覽器去訪問這個 nginx 伺服器：
緩存
Docker 守護進程會一條一條的執行 Dockerfile 中的指令，而且會在每一步提交並生成一個新鏡像，最後會輸出最終映像的ID。生成完成後，Docker 守護進程會自動清理你發送的上下文。
Dockerfile檔中的每條指令會被獨立執行，並會創建一個新鏡像，RUN cd /tmp等命令不會對下條指令產生影響。
Docker 會重用已生成的中間鏡像，以加速docker build的構建速度。以下是一個使用了緩存鏡像的執行過程：
$ docker build -t svendowideit/ambassador . Sending build context to Docker daemon 2.048kBStep 1/3 : FROM nginx---&amp;gt; 7e4d58f0e5f3Step 2/3 : MAINTAINER ianhunag@gmail.com---&amp;gt; Using cache---&amp;gt; d0140a7f8c8eStep 3/3 : RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html---&amp;gt; Using cache---&amp;gt; 81a660be4e2bSuccessfully built 81a660be4e2bSuccessfully tagged svendowideit/ambassador:latest 構建緩存僅會使用本地父生成鏈上的鏡像，如果不想使用本地緩存的鏡像，也可以通過&amp;ndash;cache-from指定緩存。指定後將不再使用本地生成的鏡像鏈，而是從鏡像倉庫中下載。
參考
Dockerfile 使用介紹 - 純潔的微笑博客
http://www.ityouknow.com/docker/2018/03/12/docker-use-dockerfile.html
</content>
    </entry>
    
     <entry>
        <title>AngularBsN02</title>
        <url>https://iankingh.github.io/post/angular/angularbsn02/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>Angular</tag><tag>FrontEnd</tag>
        </tags>
        <content type="html"> 從 0 開始的 Angular 生活 第2天-認識 Angular CLI 建立的專案架構 angular.json Angular CLI 的設定檔 ，Angular CLI v6 之前檔名 angular-cli.json為。
.editorconfig 編輯器設定檔，設定處理 tab 符號、換行等等。
官網。
.gitignore 設定git 忽略那些檔案不要加入版本控管。
karma.conf.js karma.conf.js: 是一個單元測試工具。
官網
protractor.conf.js E2E 測試，主要是測試使用者操作與想要的結果是否符合規格。
tsconfig.json TypeScript 編譯設定。
tslint.json TypeScript 程式碼風格檢查器。
package.json npm 的設定檔， scripts 區塊定義了在開發 Angular 時用到的命令 。
node_modeles 資料夾 存放npm install 後所有被下載下來所有的套件。
e2e 資料夾 存放 End-To-End Testing 所有測試的指定檔都被放在這裡。
src 資料夾(重要) 根據 Angular 官網的 Style Guide 建立而成Angular 應用程式主要的原始碼。
app 資料夾(重要) 存放app.module 的地方
index.html angular 應用程式地進入點。
style.css 在這裡它是 「global styles」也就是整個應用程式都會套用到的 CSS 定義，全部都可以寫在這裡。
main.ts main.ts 是 Angular 中 JavaScript 程式的進入點。(.ts 代表 TypeScript)
import { enableProdMode } from &#39;@angular/core&#39;;import { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;;import { AppModule } from &#39;./app/app.module&#39;;import { environment } from &#39;./environments/environment&#39;;if (environment.production) {enableProdMode();}platformBrowserDynamic().bootstrapModule(AppModule).catch(err =&amp;gt; console.error(err)); bootstrapModule 表示以引入 AppModule 啟動
app.module.ts 根目錄的TS module
import { BrowserModule } from &#39;@angular/platform-browser&#39;;import { NgModule } from &#39;@angular/core&#39;;import { FormsModule } from &#39;@angular/forms&#39;;import { AppRoutingModule } from &#39;./app-routing.module&#39;;import { AppComponent } from &#39;./app.component&#39;;@NgModule({declarations: [AppComponent],imports: [BrowserModule,AppRoutingModule,FormsModule],providers: [],bootstrap: [AppComponent]})export class AppModule { } app.component.ts import { Component } from &#39;@angular/core&#39;;@Component({selector: &#39;app-root&#39;,templateUrl: &#39;./app.component.html&#39;,styleUrls: [&#39;./app.component.scss&#39;]})export class AppComponent {title = &#39;firstAngular&#39;;} 根目錄的TS controller
assets(資產) 資料夾 放置所有的靜態檔案的資料夾，如額外的 JavaScript、JQery、CSS、圖片&amp;hellip;&amp;hellip;&amp;hellip;等等。
.gitkeep Git 無法添加完全空目錄 ，希望跟蹤Git中空目錄的人就創建了將名為&amp;quot;gitkeep &amp;ldquo;的文件，把它放在這些目錄中的慣例，該文件可以被稱為任何東西;Git對此名稱沒有特殊意義。
environments 資料夾 這個資料夾裡面所定義的是 Angular 專案內的環境變數，透過 TypeScript 定義一些環境變數。
這個資料夾內有兩個檔案，分別是 environment.ts 與 environment.prod.ts ，差別在於 environment.prod.ts 是只有當 build 出 production 版的應用程式時才用得上，否則在開發時期都是使用另一個設定檔。
favicon.ico 瀏覽器業籤上面的圖示。
polyfills.ts 當你的 Angular 應用程式同時要符合 IE 或舊版瀏覽器時，會用 Polyfill 來填充缺少的 HTML5/JS APIs
test.ts 測試 - Angular 的檔案
tsconfig.app.json Typescripe編譯成Javascript時的編譯設定
tsconfig.spec.json Typescripe編譯成Javascript時的編譯設定
參考 Angular CLI 7.3 使用 ES2015 的 nomodule 屬性載入 Polyfills 函式庫 | The Will Will Web https://blog.miniasp.com/post/2019/02/03/Angular-CLI-73-Use-ES2015-nomodule-load-polyfills
[DAY-19] Angular架構與學習資源介紹 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 https://ithelp.ithome.com.tw/articles/10225044
[從 0 開始的 Angular 生活]No.2 檔案架構 | pvt5r486&amp;rsquo;s Blog https://pvt5r486.github.io/f2e/20190520/3222844657/
</content>
    </entry>
    
     <entry>
        <title>SpringDataJapNotes</title>
        <url>https://iankingh.github.io/post/spring/springdatajapnotes/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>java</tag><tag>Spring</tag><tag>Spring Data JPA</tag>
        </tags>
        <content type="html"> Spring Data JPA 介紹 Spring-Data 概述  Spring Data 是一個資料訪問框架 ，用於簡化資料庫訪問，旨在提供一致的資料庫訪問模型，同時仍然保留不同資料庫底層資料存儲的特點，Spring Data 採用了領域驅動模型的設計思想，實現了訪問關係型數據庫、非關係型數據庫的統一的介面，只需要定義好領域模型（Entity），後續的創建表、CURD、排序操作不需要手動添加任何SQL語句，同時也支持手動擴展功能。
Spring Data 只要定義介面，遵循 Spring Data 的規範，就無需寫實現類。
Spring Data 提供了預設的交易處理方式，即所有的查詢均聲明為唯讀事務。
Spring Data 專案所支援 NoSQL 存儲：MongoDB （文檔資料庫）、Neo4j（圖形資料庫）、Redis（鍵/值存儲）、Hbase（列族資料庫）
Spring Data 專案所支援的關係資料存儲技術：JDBC、JPA
 Spring Data JPA 概述  JPA(Java Persistence API)是 Sun 官方提出的 Java 持久化規範。
JPA主要是為了簡化現有的持久化開發工作和整合 ORM 技術， 是在充分吸收了現有 Hibernate、TopLink、JDO 等 ORM 框架的基礎上發展而來的，具有易於使用、伸縮性強等優點。
Spring Data JPA 是 Spring 基於 ORM 框架、JPA 規範的基礎上封裝的一套 JPA 應用框架，可使開發者用簡單代碼即可實現對資料的訪問和操作。
它提供了包括增刪改查等在內的常用功能，且易於擴展！通常我們寫持久層，都是先寫一個介面，再寫介面對應的實現類，在實現類中進行持久層的業務邏輯處理。而現在，Spring Data JPA幫助我們自動完成了持久層的業務邏輯處理，開發者唯一要做的，就只是聲明持久層的介面，其他都交給 Spring Data JPA 來幫你完成！
注意：JPA 是一套規範，不是一套產品， Hibernate、TopLink、JDO 它們是一套產品，如果說這些產品實現了這個 JPA 規範，那麼就可以叫它們為 JPA 的實現產品。
 Repository Repository介面 Repository 介面是 Spring Data 的一個核心介面，是一個抽象的介面，使用者通過繼承該介面來實現資料的訪問，它不提供任何方法，開發者需要在自己定義的介面中聲明需要的方法
public interface Repository&amp;lt;T, ID&amp;gt; { } 很重要的一點就是，Repository的實現類是在應用啟動的時候生成的，也就是Spring的應用上下文創建的時候.而不是通過代碼生成技術產生的，也不是介面方法調用時才產生的 基礎的Repository提供了最基本的資料訪問功能，其幾個子介面則擴展了一些功能。
編寫Spring Data JPA Repository 的關鍵在於從一組介面中挑選一個進行擴展
EX:
public interface CustomerRepository extends Repository&amp;lt;CustomerEntity,Long&amp;gt; { } 添加注解為其指定 CustomerEntity和 id 屬性。
在spring boot中如果使用了 spring-boot-starter-data-jpa ,會自動掃描所有擴展了Repository介面的類
CrudRepository 介面 CrudRepository 介面繼承Repository，提供對實體類(CRUD)增刪改查方法，可以直接調用。
CrudRepository介面實現了save、delete、count、exists等方法，繼承這個介面時需要兩個範本參數T和ID，T就是你的實體類（對應資料庫表），ID就是主鍵。
public interface CrudRepository&amp;lt;T, ID extends Serializable&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; {&amp;lt;S extends T&amp;gt; S save(S entity); //Saves the given entity (保存給定的實體。)Optional&amp;lt;T&amp;gt; findById(ID primaryKey); //Returns the entity identified by the given ID.(返回由給定ID標識的實體。)Iterable&amp;lt;T&amp;gt; findAll(); //Returns all entities.(返回所有實體。)long count();//Returns the number of entities.(查詢實體數量) void delete(T entity); //	Deletes the given entity.(刪除給定的實體。)boolean existsById(ID primaryKey); //Indicates whether an entity with the given ID exists.(根據id判斷實體是否存在)void delete(ID id);//根據Id刪除實體 &amp;lt;S extends T&amp;gt; Iterable&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entities);//保存集合} 在使用中，使用者需要繼承這個介面，CustomerEntity就是定義的實體，Long是主鍵類型
public interface CustomerRepository extends CrudRepository&amp;lt;CustomerEntity, Long&amp;gt;{} package com.example.demo;import java.util.ArrayList;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/*** CustomerRepositoryTest*/@SpringBootTestpublic class CustomerRepositoryTest {@Autowiredprivate UserRepository userRepository;// CRUD 操作// 增 save(entity), save(entities)@Testpublic void save1() {UserEntity userEntity = new UserEntity();userEntity.setName(&amp;quot;肯德基20&amp;quot;);userEntity = userRepository.save(userEntity);System.out.println(userEntity);}// save(entities)@Testpublic void saveManyTest() {UserEntity userEntity = new UserEntity();userEntity.setName(&amp;quot;test21&amp;quot;);UserEntity userEntity2 = new UserEntity();userEntity2.setName(&amp;quot;test22&amp;quot;);ArrayList&amp;lt;UserEntity&amp;gt; userEntities = new ArrayList&amp;lt;UserEntity&amp;gt;();userEntities.add(userEntity);userEntities.add(userEntity2);userRepository.saveAll(userEntities);}} // 刪 delete(id),delete(entity),delete(entities),deleteAll// 查 findOne(id) ,findAll, exits(id)// save***只要 id一樣,就會更新,而不是添加. PagingAndSortingRepository 介面 繼承CrudRepository，具有分頁查詢和排序功能
public interface PagingAndSortingRepository&amp;lt;T, ID extends Serializable&amp;gt; extends CrudRepository&amp;lt;T, ID&amp;gt; {Iterable&amp;lt;T&amp;gt; findAll(Sort sort); //排序Page&amp;lt;T&amp;gt; findAll(Pageable pageable); //分頁查詢（含排序功能）} **example: **
package com.example.demo;import java.util.ArrayList;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/*** CustomerRepositoryTest*/@SpringBootTestpublic class CustomerRepositoryTest {@Autowiredprivate CustomerRepository customerRepository;@Testpublic void findAll() {Iterable iterable = customerRepository.findAll();System.out.println(&amp;quot;iterable &amp;quot; &#43; iterable);}} JpaRepository 介面 繼承 PagingAndSortingRepository，實現一組 JPA 規範相關的方法， 該介面提供了JPA的相關功能 ，PagingAndSortingRepository介面本身已經繼承了 CrudRepository
public interface JpaRepository&amp;lt;T,ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T,ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt;{List&amp;lt;T&amp;gt; findAll(); //查找所有實體List&amp;lt;T&amp;gt; findAll(Sort sort); //排序、查找所有實體List&amp;lt;T&amp;gt; save(Iterable&amp;lt;? extends T&amp;gt; entities);//保存集合T saveAndFlush(T entity);//強制執行持久化void flush();//執行緩存與資料庫同步void deleteInBatch(Iterable&amp;lt;T&amp;gt; entities);//刪除一個實體集合} JpaSpecificationExecutor介面 可以執行原生SQL查詢也可以自訂Repository的方法不屬於Repository體系，實現一組 JPA Criteria 查詢相關的方法 Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
由於JpaSpecificationExecutor 並不繼承repository 介面，所以它不能單獨使用，只能和jpa Repository 一起用。
public interface JpaSpecificationExecutor&amp;lt;T&amp;gt; {T findOne(Specification&amp;lt;T&amp;gt; spec);List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec);Page&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Pageable pageable);List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Sort sort);long count(Specification&amp;lt;T&amp;gt; spec);} public interface CustomerRepository extends CrudRepository&amp;lt;Customer, Long&amp;gt;, JpaSpecificationExecutor {} Spring-Data 方法定義規範 public interface ProductInfoRepository extends JpaRepository&amp;lt;ProductInfoEntity,String&amp;gt; {//定義一個方法:根據商品名稱查找所有的商品List&amp;lt;ProductInfoEntity&amp;gt; findAllByProductName(String name);} 當創建 Repository 實現的時候， Spring Data會檢查 Repository 介面的所有方法，解析方法的名稱，並基於被持久化的物件來推測方法的目的，Spring Data 定義了一組小型的領域特定語言(DSL) ，在這裡持久化的細節都是通過 Repository的方法簽名來描述的
findAllByProductName(String name) 方法非常簡單，Repoditory 方法是 由一個動詞，一個可選主題,關鍵字By以及一個斷言所組成
在findAllByProductName 方法中,動詞是findAll ,斷言是 ProductName，主題並沒有指定，
暗含就是 ProductInfoEntity Repository 方法的主題是可選的,它主要是讓你命名方法的時候有很多的靈活性,findAllByProductName和findAllProductInfoEntityByProductName方法沒有什麼區別. 要查詢的物件的類型是通過如何參數化 Repository 介面來決定的,而不是方法名稱中的主題.
擴展查詢 按照Spring Data 的規範，查詢方法以find | read | get 開頭， 涉及條件查詢時，條件的屬性用條件關鍵字連接，要注意的是：條件屬性以首字母大寫。
find | read | get方法都會查詢資料並返回物件.而 count 則會返回匹配對象的數量,而不是對象本身.
EX：定義一個 Entity 實體類
class UserEntity｛private String firstName; private String lastName; ｝ 使用And條件連接時，應這樣寫：
findByLastNameAndFirstName(String lastName,String firstName); 假如創建如下的查詢：findByUserDepUuid()，框架在解析該方法時，首先剔除 findBy，然後對剩下的屬性進行解析，假設查詢實體為Doc （1）先判斷 userDepUuid （根據 POJO 規範，首字母變為小寫）是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，繼續第二步； （2）從右往左截取第一個大寫字母開頭的字串(此處為Uuid)，然後檢查剩下的字串是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，則重複第二步，繼續從右往左截取；最後假設 user 為查詢實體的一個屬性； （3）接著處理剩下部分（DepUuid），先判斷 user 所對應的類型是否有depUuid屬性，如果有，則表示該方法最終是根據 “ Doc.user.depUuid” 的取值進行查詢；否則繼續按照步驟 2 的規則從右往左截取，最終表示根據 “Doc.user.dep.uuid” 的值進行查詢。 （4）可能會存在一種特殊情況，比如 Doc包含一個 user 的屬性，也有一個 userDep 屬性，此時會存在混淆。可以明確在屬性之間加上 &amp;ldquo;_&amp;rdquo; 以顯式表達意圖，比如 &amp;ldquo;findByUser_DepUuid()&amp;rdquo; 或者 &amp;ldquo;findByUserDep_uuid()&amp;rdquo; 特殊的參數： 還可以直接在方法的參數上加入分頁或排序的參數，比如：
Page&amp;lt;UserModel&amp;gt; findByName(String name, Pageable pageable);List&amp;lt;UserModel&amp;gt; findByName(String name, Sort sort); 如果覺得curdrepository提供的查詢不符合要求，可以繼承該介面進行擴展，
Spring Data JPA為此提供了一些表達條件查詢的關鍵字，大致如下：
條件的屬性名稱與個數要與參數的位置與個數一一對應 直接在介面中定義查詢方法，如果是符合規範的，可以不用寫實現，目前支援的關鍵字寫法如下：
   Keyword Description Sample     And 等價於SQL中的and 關鍵字 findByUsernameAndPassword(String user, Striang pwd)；   Or 等價於SQL中的or 關鍵字 findByUsernameOrAddress(String user, String addr);   Between 等價於SQL中的between 關鍵字 findBySalaryBetween(int max,int min)；   LessThan 等價於SQL中的&amp;quot;&amp;lt;&amp;rdquo; findBySalaryLessThan(int max)；   GreaterThan 等價於SQL中的&amp;quot;&amp;gt;&amp;rdquo; findBySalaryGreaterThan(intmin)；   IsNull 等價於SQL中的&amp;quot;is null&amp;rdquo; findByUsernameIsNull()；   IsNotNull 等價於SQL中的&amp;quot;is not null&amp;rdquo; findByUsernameIsNotNull()；   NotNull 與IsNotNull等價    Like 等價於SQL中的&amp;quot;like&amp;rdquo; findByUsernameLike(String user)；   NotLike 等價於SQL中的&amp;quot;not like&amp;rdquo; findByUsernameNotLike(Stringuser)；   OrderBy 等價於SQL中的&amp;quot;order by&amp;rdquo; findByUsernameOrderBySalaryAsc(String user)；   Not 等價於SQL中的&amp;rdquo;！ =&amp;rdquo; findByUsernameNot(String user)；   In 等價於SQL中的&amp;quot;in&amp;rdquo; findByUsernameIn(CollectionuserList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數；   NotIn 等價於SQL中的&amp;quot;not in&amp;rdquo; findByUsernameNotIn(CollectionuserList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數；    @Query注解 Spring Data 這個小型的DSL依舊有其局限性,有時候通過方法名表達預期的查詢很繁瑣,甚至無法實現.如果與呆這種情況,Spring Data能讓我們通過**@Query**注解來解決問題
這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
如果是 @Query 中有 LIKE 關鍵字，後面的參數需要前面或者後面加 %，這樣在傳遞參數值的時候就可以不加 %：
@Query注解 這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
自訂 Repository 方法 定義一個介面: 聲明要添加的, 並自實現的方法 提供該介面的實現類: 類名需在要聲明的 Repository 後添加 Impl, 並實現方法 聲明 Repository 介面, 並繼承 1) 聲明的介面 使用. 注意: 預設情況下, Spring Data 會在 base-package 中查找 &amp;ldquo;介面名Impl&amp;rdquo; 作為實現類. 也可以通過　repository-impl-postfix　聲明尾碼
@Query(&amp;quot;select o from UserModel o where o.name like %?1&amp;quot;) @Query來指定本地查詢 使用**@Query**來指定本地查詢，只要設置**nativeQuery**為**true**
@Query(value=&amp;quot;select * from tbl_user where name like %?1&amp;quot; ,nativeQuery=true) @Query 與 @Modifying 這兩個 annotation一起聲明，可定義個性化更新操作，例如只涉及某些欄位更新時最為常用
Springdata支援JPQL 語句對查詢進行擴展，
例子如下：
public interface CustomerRepository extends CrudRepository&amp;lt;Customer, Long&amp;gt; { @Query(&amp;quot;select a from Customer a WHERE a.firstName = ?&amp;quot;)List&amp;lt;Customer&amp;gt; findByQuery(StringfirstName); }  EX:
//聲明自訂查詢/***	使用JPA SQL語句*	@return**/@Query(&amp;quot;select p from ProductInfoEntity p where p.productName like &#39;%米%&#39; &amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findProductInfo(); /***	使用JPA SQL語句 查詢價格最高的商品**/@Query(&amp;quot;select p from ProductInfoEntity p &amp;quot; &#43;&amp;quot;where p.productPrice=&amp;quot; &#43;&amp;quot;(select max(p2.productPrice) from ProductInfoEntity p2)&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findMaxPrice(); /*** 使用JPA SQL語句 帶參數的查詢1* @param name* @param price* @return**/@Query(&amp;quot;select o from ProductInfoEntity o where o.productName=?1 and o.productPrice=?2&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findParam(String name, double price); /*** 使用JPASQL語句 帶參數的查詢2* @param name* @param price* @return**/@Query(&amp;quot;select o from ProductInfoEntity o where o.productName=:name and o.productPrice=:price&amp;quot;)List&amp;lt;ProductInfoEntity&amp;gt; findParam2(@Param(&amp;quot;name&amp;quot;) String name, @Param(&amp;quot;price&amp;quot;) double price);當然還可以使用原生SQL語句進行查詢,只需要 nativeQuery = true 即可 /***使用原生SQL語句 查詢* @return**/@Query(nativeQuery = true,value = &amp;quot;select count(*) from product_info&amp;quot;)Integer getCount(); Spring data JPA 更新及刪除操作整合事物的使用
更新操作注意事項:
/** 使用Query注解寫更新JPA語句*添加 @Modifying 注解**/@Modifying@Query(&amp;quot;update ProductInfoEntity o set o.productPrice =:price where o.productId=:id&amp;quot;)Integer updatePrice(@Param(&amp;quot;id&amp;quot;) String id,@Param(&amp;quot;price&amp;quot;) double price);  在service層添加事物 @Transactional  package com.itguang.weixinsell.service;import com.itguang.weixinsell.repository.ProductInfoRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Transactionalpublic class ProductInfoService {@Autowiredprivate ProductInfoRepository infoRepository;public Integer updatePrice( String id,double price){Integer i = infoRepository.updatePrice(id, price);return i;}}</content>
    </entry>
    
     <entry>
        <title>docker 指令</title>
        <url>https://iankingh.github.io/post/docker/docker_command/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>docker</tag>
        </tags>
        <content type="html"> images see images(看映像) docker images docker pull(下載映像) docker pull see registry images curl -XGET 172.22.11.11:5000/v2/_catalog container docker container ls (看容器) docker container ls docker ps (看容器) docker ps -a : 看到的所有容器 docker ps -a  -l :顯示最新創建的容器(包括所有狀態) docker ps -l -q :只顯示數字ID docker ps -q  -f: 過濾器 docker ps -f id(ContainerId) Container Stop (停掉Container) docker stop  Container remove(移除停掉的Container) docker rm see log docker logs Show Container&amp;rsquo;s logs (once) docker logs ContainerId Log countinuing docker logs -f ContainerId See Container ENV docker inspect Cid &amp;gt; Y.txt (獲取容器/鏡像的 ENV。) Into Container (進入 container 裡面) docker exec -it containerID bash  into 執行命令 docker exec -it ebbeb7c38404 bash -c &#39;echo &amp;quot;$envKey&amp;quot;&#39; stop &amp;amp;&amp;amp; rm docker container docker stop ContainerId &amp;amp;&amp;amp; docker rm ContainerId Container status (查看docker 容器使用的資源) docker stats  提交一個commit docker commit cID docker system docker system df (空間分佈) docker system df 可用於查詢鏡像（Images）、容器（Containers）和本地卷（Local Volumes）等空間使用大戶的空間佔用情況。
-v 表示細節查看空間佔用細節 docker system df -v docker system prune (空間清理) 可以通過 Docker 內置的 CLI 指令 docker system prune 來進行自動空間清理。
docker system prune WARNING! This will remove:
- all stopped containers (已經停止的容器（container）)
- all networks not used by at least one container(未被使用的網路)
- all dangling images(Dangling images are layers that have no relationship to any tagged images.)(所有未打標籤的鏡像(images)。)
- all dangling build cache(構建鏡像時產生的緩存)
該指令預設只會清除懸空鏡像，未被使用的鏡像不會被刪除。
· 添加 -a 或 --all 參數後，可以一併清除所有未使用的鏡像和懸空鏡像。
· 可以添加 -f 或 --force 參數用以忽略相關告警確認資訊。
· 指令結尾處會顯示總計清理釋放的空間大小。
刪除已經停止的容器： docker container prune 刪除未被使用的網路： docker network prune 刪除沒有Tag的鏡像： docker image prune 刪除沒有容器的鏡像： docker image prune -a 刪除未被使用的資料卷： docker volume prune Docker swarm see swarm service ls docker service ls see swarm service status docker service ps serviceID update service env docker service update --env-add envKey=envValue serviceName update service docker service update --image 172.22.11.11:5000/dockerImageName:tag swarmS_Name 參考 docker 官網
Docker常用命令小记_程序员欣宸的博客-CSDN博客
https://blog.csdn.net/boling_cavalry/article/details/101145739
docker container ls命令 - Docker教程™
https://www.yiibai.com/docker/container_ls.html
</content>
    </entry>
    
     <entry>
        <title>Java DecimalFormat(數字格式)</title>
        <url>https://iankingh.github.io/post/java/java_decimalformat/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 簡介 java.text提供了NumberFormat類別來讓我們更方便的格式化數字的呈現方式
DecimalFormat是NumberFormat該格式的具體子類， 其格式為小數。它具有多種功能，旨在使可以在任何語言環境中解析和格式化數字，包括對西方，阿拉伯和印度數字的支持。它還支持各種數字，包括整數（123），定點數字（123.4），科學計數法（1.23E4），百分比（12％）和貨幣金額（$ 123）。所有這些都可以本地化。
基本用法 NumberFormat //	由於NumberFormat是一個抽象類別，必須用getInstance()來取得他裡面的方法NumberFormat nf = NumberFormat.getInstance();//	NumberFormat物件格式化的方式是固定的，都是以每三位數一個逗號的方式格式化數字，浮點數欄位則是有的時候顯示，沒有就不顯示。所以可以得到1,234,567.89。System.out.println(nf.format(1234567.89)); DecimalFormat ​	DecimalFormat實作了NumberFormat，並提供更客製化的格式選擇，用法如下：
Double value = 123456.789;String pattern = &amp;quot;###,###.###&amp;quot; ;//	宣告了一個DecimalFormat物件，並可以在宣告時帶入要格式化的格式，若不帶入參數，格式規則和NumberFormat相同。DecimalFormat myFormatter = new DecimalFormat(pattern);String output = myFormatter.format(value);System.out.println(&amp;quot;執行結果為：&amp;quot; &#43; value &#43; &amp;quot; &amp;quot; &#43; pattern &#43; &amp;quot; &amp;quot; &#43; output); ​	下表描述了前幾行代碼的輸出. value 是要格式化的數字(double) ,pattern 是指定格式設置屬性的字符串.The output, 輸出是字符串，表示格式化的數字。
   value pattern output Explanation     123456.789 ###,###.### 123,456.789 井號（＃）表示一個數字，逗號是分組分隔符的佔位符，句點是十進制分隔符的佔位符。   123456.789 ###.## 123456.79 value 在小數點右邊有三位數, 而 pattern 只有兩位. format通過四捨五入來解決這個問題。   123.78 000000.000 000123.780 pattern 指定前導零和尾隨零，因為使用0字符代替了井號（＃）。   12345.67 $###,###.### $12,345.67 pattern中的第一個字符是美元符號（$）。注意，它緊接在格式為output的最左邊的數字之前。   12345.67 \u00A5###,###.### ¥12,345.67 pattern 使用Unicode值00A5指定日元（¥）的貨幣符號。    其他用法 DecimalFormat df = new DecimalFormat(&amp;quot;$#,##0.00&amp;quot;);System.out.println(df.format(1234567.2)); ​	格式化的字串中0代表一定要有值，#則代表不一定要有值， 因此#,##0.00表示至少要有個位數及小數點後兩位，且每三位數以一個逗號分開，若格式化的數字沒有個位數或小數點後兩位，就會以0代替。
​	根據需求在前後加上需要的文字，例如$符號，所以上例執行的結果就會是$1,234,567.20。
這邊要注意若是我們在格式化字串結尾加上百分比符號『%』，DecimalFormat會自動幫我們將數值乘以100以符合字面意義，例如：
DecimalFormat df = new DecimalFormat(&amp;quot;#,##0.00%&amp;quot;);System.out.println(&amp;quot;執行結果為：&amp;quot; &#43; df.format(1234567.2));// 執行結果為：123,456,720.00% DecimalFormat 類主要靠 # 和 0 兩種預留位置號來指定數位長度。
0 表示如果位數不足則以 0 填充，# 表示只要有可能就把數字拉上這個位置。
/*** DecimalFormatTest*/public class DecimalFormatTest {public static void main(String[] args) {double d = 123456789;DecimalFormat decimalFormat = new DecimalFormat(&amp;quot;#,###.##&amp;quot;);System.out.println(decimalFormat.format(d));DecimalFormat decimalFormat2 = new DecimalFormat(&amp;quot;#,###.00&amp;quot;);System.out.println(decimalFormat2.format(d));double pi = 3.1415927;// 圓周率// 取一位元整數System.out.println(new DecimalFormat(&amp;quot;0&amp;quot;).format(pi));// 3// 取一位元整數和兩位元小數System.out.println(new DecimalFormat(&amp;quot;0.00&amp;quot;).format(pi));// 3.14// 取兩位元整數和三位元小數，整數不足部分以0填補。System.out.println(new DecimalFormat(&amp;quot;00.000&amp;quot;).format(pi));// 03.142// 取所有整數部分System.out.println(new DecimalFormat(&amp;quot;#&amp;quot;).format(pi));// 3// 以百分比方式計數，並取兩位小數System.out.println(new DecimalFormat(&amp;quot;#.##%&amp;quot;).format(pi));// 314.16%long c = 299792458;// 光速// 顯示為科學計數法，並取五位小數System.out.println(new DecimalFormat(&amp;quot;#.#####E0&amp;quot;).format(c));// 2.99792E8// 顯示為兩位元整數的科學計數法，並取四位小數System.out.println(new DecimalFormat(&amp;quot;00.####E0&amp;quot;).format(c));// 29.9792E7// 每三位以逗號進行分隔。System.out.println(new DecimalFormat(&amp;quot;,###&amp;quot;).format(c));// 299,792,458// 將格式嵌入文本System.out.println(new DecimalFormat(&amp;quot;光速大小為每秒,###米&amp;quot;).format(c)); // 光速大小為每秒299,792,458米}} 參考 [Java] 13-8 數字輸出格式 @ 給你魚竿 :: 痞客邦
https://rx1226.pixnet.net/blog/post/335106917
數字格式(NumberFormat、DecimalFormat) @ Penguin 工作室，一起JAVA吧！ :: 隨意窩 Xuite日誌
https://blog.xuite.net/jane17512001/PenguinDesign/116288108-%E6%95%B8%E5%AD%97%E6%A0%BC%E5%BC%8F%28NumberFormat%E3%80%81DecimalFormat%29
（轉）Java DecimalFormat 用法（數位格式化） - 濫好人 - 博客園
https://www.cnblogs.com/hq233/p/6539107.html
https://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html
https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html
</content>
    </entry>
    
     <entry>
        <title>[從 0 開始的 JAVA 生活]No.0 java環境變數 (Environment Variable)設定</title>
        <url>https://iankingh.github.io/post/java/java_tutorial_0/</url>
        <categories>
          <category>筆記</category><category>技術</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 設定JAVA_HOME C:\Program Files\Java\jdk1.8.0_111(後面為自己的jdk) Path %JAVA_HOME%\bin; 測試 java -vresionjavac -version </content>
    </entry>
    
     <entry>
        <title>RedisInstall</title>
        <url>https://iankingh.github.io/post/redis/redisinstall/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>redis</tag>
        </tags>
        <content type="html"> 簡介 Redis是一個使用ANSI C編寫的開源、支援網路、基於記憶體、可選永續性的鍵值對儲存資料庫。
安裝 Window 下 安裝 安裝網址 https://github.com/microsoftarchive/redis/releases
啟動指令 redis-server.exe redis.windows.conf 啟動畫面 測試 //連線指令redis-cli.exe -h 127.0.0.1 -p 6379// 塞值Set testkey testvalue// 取值Get testkey Linux 安裝 $ wget http://download.redis.io/releases/redis-6.0.3.tar.gz$ tar xzf redis-6.0.3.tar.gz$ cd redis-6.0.3$ make 啟動 src/redis-server 測試 //連線指令src/redis-cli // 塞值redis&amp;gt; set foo bar // 取值redis&amp;gt; get foo  參考 Redis - 維基百科，自由的百科全書
https://zh.wikipedia.org/wiki/Redis
Redis - 在 Windows 上建立高可用性的 Redis | 天空的垃圾場
https://skychang.github.io/2017/04/09/Redis-Create_Redis_HA/
Redis系列 - 環境建置篇 - Jed&amp;rsquo;s blog
https://jed1978.github.io/2018/05/02/Redis-Environment-Installation-Configuration.html
</content>
    </entry>
    
     <entry>
        <title>[從 0 開始的 JAVA 生活]No.2 Java 基本的資料型態(Primitive Data Types)</title>
        <url>https://iankingh.github.io/post/java/java_tutorial_1/</url>
        <categories>
          <category>筆記</category><category>技術</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> Java 基本的資料型態(Primitive Data Types)    序號 數據類型 大小/位 封裝類 默認值 可表示數據范圍     1 byte 8bit Byte 0 -128~127   2 short 16bit Short 0 -32768~32767   3 int 32bit Integer 0 -2147483648~2147483647   4 long 64bit Long 0L -9223372036854775808~9223372036854775807   5 float 32bit Float 0.0F 1.4E-45~3.4028235E38   6 double 64bit Double 0.0D 4.9E-324~1.7976931348623157E308   7 char 16bit Character &amp;lsquo;\u0000&amp;rsquo; 0~65535   8 boolean 8bit Boolean false true或false    範例 package ch1;/*** * * &amp;lt;p/&amp;gt;* Package: ch1 &amp;lt;br&amp;gt;* File Name: PrimitiveDataTypesTest &amp;lt;br&amp;gt;* &amp;lt;p/&amp;gt;* Purpose: &amp;lt;br&amp;gt;* * @ClassName: ch1.PrimitiveDataTypesTest* @Description: 測試基本數據類型* @Copyright : Copyright (c) Corp. 2020. All Rights Reserved.* @Company: ian Team.* @author ian* @version 1.0, 2020年5月18日*/public class PrimitiveDataTypesTest {static byte b;static short s;static int i;static long l;static float f;static double d;static char c;static boolean bo;// String不是基本類型static String str1 = &amp;quot;&amp;quot;;// 生成一個String類型的引用，而且分配記憶體空間來存放&amp;quot;&amp;quot;;static String str2; // 只生成一個string類型的引用；不分配記憶體空間,預設為nullpublic static void main(String[] args) {System.out.println(&amp;quot;byte的大小：&amp;quot; &#43; Byte.SIZE &#43; &amp;quot; byte的預設值：&amp;quot; &#43; b &#43; &amp;quot; byte的資料範圍：&amp;quot; &#43; Byte.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Byte.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;short的大小：&amp;quot; &#43; Short.SIZE &#43; &amp;quot; short的預設值：&amp;quot; &#43; s &#43; &amp;quot; short的資料範圍：&amp;quot; &#43; Short.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Short.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;int的大小：&amp;quot; &#43; Integer.SIZE &#43; &amp;quot; int的預設值：&amp;quot; &#43; i &#43; &amp;quot; int的資料範圍：&amp;quot; &#43; Integer.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Integer.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;long的大小：&amp;quot; &#43; Long.SIZE &#43; &amp;quot; long的預設值：&amp;quot; &#43; l &#43; &amp;quot; long的資料範圍：&amp;quot; &#43; Long.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Long.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;float的大小：&amp;quot; &#43; Float.SIZE &#43; &amp;quot; float的預設值：&amp;quot; &#43; f &#43; &amp;quot; float的資料範圍：&amp;quot; &#43; Float.MIN_VALUE &#43; &amp;quot;~&amp;quot;&#43; Float.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;double的大小：&amp;quot; &#43; Double.SIZE &#43; &amp;quot; double的預設值：&amp;quot; &#43; d &#43; &amp;quot; double的資料範圍：&amp;quot; &#43; Double.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Double.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;char的大小：&amp;quot; &#43; Character.SIZE &#43; &amp;quot; char的預設值：&amp;quot; &#43; c &#43; &amp;quot; char的資料範圍：&amp;quot; &#43; Character.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Character.MAX_VALUE);System.out.println(&amp;quot;----------------------------------------------------&amp;quot;);System.out.println(&amp;quot;boolean的大小：&amp;quot; &#43; Byte.SIZE &#43; &amp;quot; boolean的預設值：&amp;quot; &#43; bo &#43; &amp;quot; boolean的資料範圍：&amp;quot; &#43; Byte.MIN_VALUE&#43; &amp;quot;~&amp;quot; &#43; Byte.MAX_VALUE);System.out.println(&amp;quot;String字串的預設值：&amp;quot; &#43; str1 &#43; &amp;quot;str的默認長度：&amp;quot; &#43; str1.length());System.out.println(&amp;quot;String字串的預設值：&amp;quot; &#43; str2);}} JAVA 跳脫字元 Escape Characters - \&#39; : 單引號- \&amp;quot; : 雙引號- \\ : 反斜線- \n : 換行- \t : tab鍵- \b : 倒退一格- \f : 換頁- \r : Enter 鍵 參考
Java中8種基本數據類型默認的默認值_java_飛月程序人生-CSDN博客
https://blog.csdn.net/fysuccess/article/details/40656761
</content>
    </entry>
    
     <entry>
        <title>GitLab error</title>
        <url>https://iankingh.github.io/post/git/gitlab%E5%95%8F%E9%A1%8C/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html"> 連線GitLab問題處理 問題1 : 在連線 gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題
可能是有人重灌gitlab 或是改密碼時造成 憑證用舊的對新的 gitlab 密碼
Windows 解法
解決方法1 : 到 win10 的控制台/認證管理員/ Windows 認證
或到搜尋輸入
Credential Manager / Windows Credentials/
找到 對應的 gitlab 把他移除
1.Credential Manager
2.Windows Credentials
參考 在gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題 | Frank的探索之旅 - 點部落
https://dotblogs.com.tw/zeroade/2018/10/11/111941
</content>
    </entry>
    
     <entry>
        <title>OpenTypeHierarchy</title>
        <url>https://iankingh.github.io/post/eclipse/opentypehierarchy/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>eclispe</tag>
        </tags>
        <content type="html"> Eclipse 用 Open Type Hierarchy 查看類的繼承關係 用Open Type Hierarchy可以查看類的繼承關係，可以在Hierarchy窗口看到繼承層次的導航。
在方法或類名上點擊右鍵，選擇Open Type Hierarchy即可，快捷鍵是F4。
</content>
    </entry>
    
     <entry>
        <title>Hugo 使用 disqus</title>
        <url>https://iankingh.github.io/post/hugo/hugoaddisqus/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> Hugo ADD disqus Disqus（/dɪsˈkʌs/，與英語「discuss」同音）是一家使用社群網路形式，向網路社區提供網站留言服務的公司。 該公司的平台提供不同的功能，例如與不同社群網路服務連結、社群網路、用戶個人檔案、垃圾宣傳及審核工具、資料分析、電子郵件通知和在行動裝置留言等。
Config.toml 開啟Hugo配置檔 Config.toml，設定 DisqusShortname。
disqusShortname = &amp;quot;yourDisqusShortname&amp;quot; 新增 disqus.html 在根目錄 /layouts/partials/ 裡新增 disqus.html 檔案， 然後把官方提供的 Script 貼到 disqus.html 檔案裡並存檔。 官方提供的 Script 如下：
&amp;lt;div id=&amp;quot;disqus_thread&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;(function () {// Don&#39;t ever inject Disqus on localhost--it creates unwanted// discussions from &#39;localhost:1313&#39; on your Disqus account...if (window.location.hostname == &amp;quot;localhost&amp;quot;)return;var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;var disqus_shortname = &#39;{{ .Site.DisqusShortname }}&#39;;dsq.src = &#39;//&#39; &#43; disqus_shortname &#43; &#39;.disqus.com/embed.js&#39;;(document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);})();&amp;lt;/script&amp;gt;&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&amp;quot;http://disqus.com/?ref_noscript&amp;quot;&amp;gt;comments powered byDisqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;&amp;lt;a href=&amp;quot;http://disqus.com/&amp;quot; class=&amp;quot;dsq-brlink&amp;quot;&amp;gt;comments powered by &amp;lt;span class=&amp;quot;logo-disqus&amp;quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt; 設定 disqus.html 到 Hugo 主題的目錄下，找到 single.html 檔案， 將 Hugo 主題的目錄下 single.html Copy 至 /layouts/_default/ 下。 開啟 /layouts/_default/single.html 檔案，貼上下方語法
&amp;lt;div class=&amp;quot;disqus markdown&amp;quot;&amp;gt;{{ partial &amp;quot;disqus.html&amp;quot; . }}&amp;lt;/div&amp;gt; 解決 localhost 不顯示 的問題 這是因為官方所提供的 Script 裡面其中一段語法的關係 if (window.location.hostname == &amp;ldquo;localhost&amp;rdquo;) return; 它的作用是當本地端 Server 運行時，就 return 中止，所以我們才會看不到 Disqus，這是因為當自己在編輯文章並運行 Server 進行預覽時，不需要用到留言的功能，所以才會採用這個判斷式來避免本地端的 Server 模式啟用Disqus功能。若您希望在本地端 Server 模式下，也能看到 Disqus，只要把上述那二行給註解掉並存檔就可以了。 ShowDisqus
參考 Hugo 加入 Disqus 整合性留言管理系統
https://coreychen71.github.io/posts/2019-05/hugoadddisqus/
给Hugo添加disqus评论服务 - Marvin&amp;rsquo;s Blog【程式人生】
https://zh4ui.net/post/2017-04-20-hugo-with-disqus/
为你博客添加disqus评论系统 | 23.9K | Vineo
https://vineo.cn/config-disqus.html
</content>
    </entry>
    
     <entry>
        <title>Prism.js使用筆記</title>
        <url>https://iankingh.github.io/post/hugo/hugoaddprism/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> hugo使用Prism.js 使用 prism.js 做為代碼高量的工具
Prism是一種輕量級的，可擴展的語法突出顯示工具，其構建考慮了現代Web標準。它已在數千個網站中使用，包括您每天訪問的一些網站。
下載 https://prismjs.com/
使用 你的Hugo部落格資料夾位置├── static│ ├── prism.js│ └── prism.css Config.toml 開啟Hugo配置檔 Config.toml，設定將預設代碼高亮設定false
#預設代碼區塊pygmentsCodefences = falsepygmentsCodefencesGuessSyntax = false 參考 Hugo動態加載prism.js https://www.ariesme.com/post/2019/add_prism_for_hugo_automatically/
Hugo / 如何在 Hugo 中用 Prism.js 提供程式碼色彩標註 | sujj blog
https://sujingjhong.com/posts/how-to-add-prismjs-into-hugo/
漂亮的代碼語法高亮插件Prism.js簡單使用文檔 - 嚴穎專欄 -SegmentFault 思否
https://segmentfault.com/a/1190000009122617
</content>
    </entry>
    
     <entry>
        <title>Hugo使用筆記</title>
        <url>https://iankingh.github.io/post/hugo/hugonotes/</url>
        <categories>
          <category>筆記</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> Hugo使用筆記 安裝 scoop install hugo hugo version  建立新Blog hugo new site blog  新增文章 hugo new post/文章名稱.md  生成的文件默認為會帶上 draft: true標記，不會發布。
hugo server -D  插入圖片 ![Example image](/static/image.png)  建立及設定部落格專案
我們先使用 hugo 命令新增一個空白專案，然後下載一個Template到我們的專案裡面
接著新增四個我們想加到模板 Menu 的頁面: about, history, tags, categories
最後則是新增一篇空白的文章到專案內。
1.create the project $ hugo new site myblog 2.add a theme $ git submodule add https://github.com/laozhu/hugo-nuo themes/hugo-nuo 3.add new pages $ hugo new about.md $ hugo new hisroty.md $ hugo new tags.md $ hugo new categories.md 4.add new article $ hugo new post/welcome.md hugo server -D  參考 右上角github 貓
GitHub Corners
http://tholman.com/github-corners/
在 Github Pages 建立 Hugo 靜態網站 · Kaichu.io
https://kaichu.io/2015/07/12/my-first-post/
使用Github部署Hugo靜態網站
https://kira5033.github.io/2019/05/%E4%BD%BF%E7%94%A8github%E9%83%A8%E7%BD%B2hugo%E9%9D%9C%E6%85%8B%E7%B6%B2%E7%AB%99/
https://github.com/xtfly/xtfly.github.io/tree/hugo/themes/next
使用 Hugo 打造個人部落格
https://blog.walker088.tw/post/intro-hugo/
hugo搭建静态博客 | 生信笔记 https://www.bioinfo-scrounger.com/archives/809/
使用Hugo搭建博客系统 - XniLe - Ops 2.0
https://blog.dianduidian.com/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/
</content>
    </entry>
    
</search>